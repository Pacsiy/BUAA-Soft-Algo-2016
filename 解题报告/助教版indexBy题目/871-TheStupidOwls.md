#871 The stupid owls
##分析

emmm怕英语表述的不到位，决定给Hint...但是  
看了大家的解题报告，看来我的Hint给的还是太直白了  
这的确是个完全错排的问题，但希望大家不只是百度了一下直接用了人家的公式而是真的明白这个递推公式的含义  
设n封信完全错排的方式有f\[n\]种。
这样想，第一封信是送错的，那么有(n-1)种选择，假设放在了位置k；信k也是送错的，这是它有两类选择：如果它正好在第一封信本该到的位置，那么剩下的n-2封信就是新的完全错排问题有f\[n-2\]种方法；如果没有放在第一封信的位置，那这就是(n-1)封信的错排（可以理解为此时第k封新本应送到第1个位置但是为了错排不能送，也就是n-1封信情况下的完全错排）。所以有 f\[n\]=(n-1)\*(f\[n-1\]+f\[n-2\]);
有了这个推导公式后就可以自底向上的推导。记得要同时记录总的排列数，n封信的话有n!种排列方式，相除即可。记得用long long来存储。  
上机的时候有同学不太理解这个概率是怎么回事，f\[n\]算的是完全错排有多少种选择，应当再除以n!也就是送n封信全部的可能
##代码样例
```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
long long f[30];
long long b[30];
int main()
{

    int c,n;
    f[1]=0; b[1]=1;
    f[2]= 1; b[2]= 2;
    f[3]=2; b[3]=6;
    for(int i= 4;i<=20;i++)
      {
          b[i]=b[i-1]*i;
        f[i]=(i-1)*(f[i-1]+f[i-2]);
      }

           while(~scanf("%d",&n)){
     double ans = (double)f[n]/b[n];
      ans = ans*100;

      printf("%.2lf%%\n",ans);
           }


}

```
##算法分析
用递归的方法也可以做，但是会慢很多；
建议用递推的方式自底向上，O(n) 的时间内就可以了
