# 860 AlvinZH去图书馆

前言：由于助教的错误操作，此题的错误数据给大家上机造成影响，在此表示歉意；同时感谢李明同学和郭镕昊同学，在上机时勇于怀疑题目问题，在此提出鼓励。

## 错误的思路

递推，像斐波那契数列那样递推。 本题可以先转化成从第0块砖走到第n块砖的方法数，令 $F[i]$ 代表走到第 $i$ 块砖的方法数。

## 错误的分析

求走到第 $i$ 块砖的方法数： ①从第 $i-1$ 块砖走来，$F[i-1]$； ②从第 $i-2$ 块砖走来，$F[i-2]$； ③从第 $i-3$ 块砖走来，$F[i-3]$， 这里面，得减去走到 $i-3$ 的前一步也是骚操作的情况，那不就是 $F(i-6)$ 么。 最后得到： $F[i] = F[i-1] + F[i-2] + F[i-3] - F[i-6]$。

## 纠错

错在哪呢？错在减去的那个部分！

我们要减去的就是走到 $i-3$ 的前一步也是骚操作的情况吗？

仔细想想，你别忘了， $F[i-6]$ 里面也有最后一步是骚操作的情况（从 $i-9$ 直接骚操作），这些情况不应该被减去。

所以，这样算出来的答案比真实答案小。这种情况从 $n≥9$ 开始就会体现，这也是一部分同学从AC到0.5分的原因。

假设走一次骚操作会导致脚疼，那么我们要减去的是**在 $i-6$ 位置脚不疼的情况**。

所以，也可以推出上面的错误方法多减去的是 $i-6$ 位置脚疼的情况。

## 正确的解决方案

如何避免上述多减的情况？我们可以开两个一维数组:

$f[52]$ ：$f[i]$ 同上 $F[i]$ ，表示走到 $i$ 位置的方法数。

$g[52]$ ：$g[i]$ 表示走到 $i$ 位置**脚不疼**的方法数。

这样的话，递推公式变成 $f[i] = f[i - 1] + f[i - 2] + g[i - 3]$ ，而 $g[i] = f[i - 1] + f[i - 2]$ ，请参考参考代码一。

还有一种思路，其实是异曲同工，在此做简单解释。

二维数组 $step[52][2]$ ：其中第二维为状态位，为0表示脚不疼，为1表示脚疼。

递推公式： $step[n][0] = step[n-1][0] + step[n-2][0] + step[n-1][1] + step[n-2][1]$ ，而 $step[n][1] = step[n-3][0]$ ，请参考参考代码二。

上面二维数组变成两个一维数组效果相同，多数同学使用这种方法。

## 参考代码一

```c++
//感谢@Author: 骆嘉航

#include <cstdio>

long long f[52];
long long g[52];//走到第i块砖不疼的方法数
int n;

int main()
{
    f[0] = 1;
    f[1] = 1;
    g[0] = 1;
    g[1] = 1;
    for(int i = 2;i <= 50; i++)
    {
        f[i] = f[i - 1] + f[i - 2] + g[i - 3];
        g[i] = f[i - 1] + f[i - 2];
    }
    while(~scanf("%d", &n))
    {
        printf("%lld\n", f[n]);
    }
    return 0;
}
```

## 参考代码二

```c++
//感谢@Author:李明

#include <iostream>
using namespace std;

long long step[51][2];
int n;

int main()
{
    step[1][0] = 1;
    step[1][1] = 0;
    step[2][0] = 2;
    step[2][1] = 0;
    step[3][0] = 3;
    step[3][1] = 1;
    for(n = 4; n < 51; ++n)
    {
        step[n][0] = step[n-1][0] + step[n-2][0] + step[n-1][1] + step[n-2][1];
        step[n][1] = step[n-3][0];
    }
    while(cin >> n)
    {
        cout << step[n][1] + step[n][0] << endl;
    }
    return 0;
}
```
